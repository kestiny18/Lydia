# Task Execution Chain Design

## Background
Lydia must consistently complete user tasks end-to-end. Strategy evolution only matters if the core execution chain is reliable. This document defines the execution chain from user input to feedback, and specifies how it integrates with the current architecture.

## Goals
- Provide a single, end-to-end task execution chain that is traceable and verifiable.
- Make intent understanding and planning outputs structured and machine-checked.
- Ensure each step has dependencies, risk tags, and verification criteria.
- Produce a final task report and capture user feedback.
- Integrate directly with existing modules (Agent, IntentAnalyzer, SimplePlanner, MemoryManager, MCP, Strategy).

## Non-Goals
- Replacing the strategy evolution system.
- Introducing external orchestration services.
- Full UI redesign in the dashboard (only minimal report surfaces).

## Core Chain
1. User Request
2. Intent Understanding (IntentProfile)
3. Context Assembly (TaskContext)
4. Plan Generation (Plan with dependencies and verification)
5. Execution Orchestration (StepResults)
6. Result Aggregation (ExecutionSummary)
7. Report Generation (TaskReport)
8. Feedback Capture (TaskFeedback)

## Architecture Fit
This design extends the current Core Engine Layer without creating new standalone systems. It reuses:
- IntentAnalyzer (packages/core/src/strategy/intent.ts)
- SimplePlanner (packages/core/src/strategy/planner.ts)
- Agent runtime (packages/core/src/execution/agent.ts)
- MemoryManager (packages/core/src/memory/manager.ts)
- MCP tools, SkillRegistry, Strategy schema

## Data Model (Proposed)

### IntentProfile
Extends the current Intent with required fields for execution.
```ts
type IntentProfile = {
  category: 'query' | 'action' | 'script' | 'unknown';
  summary: string;
  entities?: string[];
  complexity: 'simple' | 'medium' | 'complex';
  goal: string;
  deliverables: string[];
  constraints: string[];
  successCriteria: string[];
  assumptions?: string[];
  requiredTools?: string[];
};
```

### TaskContext
```ts
type TaskContext = {
  cwd: string;
  tools: string[];
  strategyId: string;
  strategyVersion: string;
  facts: Fact[];
  episodes: Episode[];
  riskPolicy: {
    requiresConfirmation: string[];
    deniedTools: string[];
  };
};
```

### PlanStep (Extended)
```ts
type PlanStep = {
  id: string;
  type: 'thought' | 'action' | 'system';
  description: string;
  tool?: string;
  args?: Record<string, unknown>;
  dependsOn?: string[];
  riskLevel?: 'low' | 'medium' | 'high';
  requiresConfirmation?: boolean;
  verification?: string[];
};
```

### StepResult
```ts
type StepResult = {
  stepId: string;
  status: 'completed' | 'failed' | 'skipped';
  output?: string;
  error?: string;
  durationMs?: number;
  verificationStatus?: 'pending' | 'passed' | 'failed';
};
```

### ExecutionSummary
```ts
type ExecutionSummary = {
  taskId: string;
  stepsTotal: number;
  stepsCompleted: number;
  stepsFailed: number;
  outputs: string[];
  failures: Array<{ stepId: string; reason: string }>;
  artifacts: Array<{ path: string; description?: string }>;
};
```

### TaskReport
```ts
type TaskReport = {
  taskId: string;
  intentSummary: string;
  success: boolean;
  summary: string;
  outputs: string[];
  followUps: string[];
  verificationNotes?: string[];
};
```

### TaskFeedback
```ts
type TaskFeedback = {
  taskId: string;
  rating?: 'positive' | 'neutral' | 'negative';
  comment?: string;
  corrections?: string[];
};
```

## Execution Flow (Detailed)
1. IntentAnalyzer returns IntentProfile (schema-validated).
2. Agent builds TaskContext from:
   - MemoryManager facts and episodes
   - Strategy constraints and preferences
   - Available MCP tools
3. SimplePlanner creates PlanStep list with dependencies and verification steps.
4. Agent executes steps in dependency order:
   - Check risk gating and user confirmations
   - Record traces for each step
   - Run verification steps where defined
5. ExecutionSummary is built from StepResults + traces.
6. TaskReport is generated by a Reporter module.
7. Feedback is requested (ask_user) for high impact tasks or on failure.
8. Report and feedback are stored in MemoryManager.

## New Modules (Minimal Additions)
- `Reporter` (packages/core/src/reporting/reporter.ts)
  - Builds TaskReport from ExecutionSummary and IntentProfile.
- `FeedbackCollector` (packages/core/src/feedback/collector.ts)
  - Prompts user for feedback and stores TaskFeedback.

## Memory Storage Additions
Extend MemoryManager with:
- `task_reports` table: report JSON + timestamps
- `task_feedback` table: feedback JSON + timestamps

## Strategy Integration
Strategy schema should influence the chain:
- `preferences.userConfirmation` affects feedback prompts.
- `constraints.mustConfirmBefore` affects step risk gating.
- `constraints.deniedTools` blocks unsafe steps.

## Failure and Recovery
- If a step fails, mark `StepResult` failed and allow targeted replan.
- Replan is limited to steps downstream of failure.
- Reporter should surface partial results and failure root cause.

## Observability
Use existing Episode + Trace storage plus new TaskReport to provide:
- Step timing and tool usage
- Failure reasons and verification status
- Final summary and artifacts

## Testing Plan
- Unit tests for IntentProfile schema parsing.
- Planner test: steps include dependencies and verification.
- Agent test: full chain outputs TaskReport.
- Memory tests: store and retrieve task_reports and task_feedback.

## Milestones
1. IntentProfile schema and parsing.
2. Planner output upgrades (deps + verification).
3. TaskReporter + FeedbackCollector.
4. Memory tables + CLI/Dashboard surfaces.

